import { Router } from 'express';
import { getPool, sql } from '../db/pool';
import { asyncHandler, badRequest, ok, listOk, notFound, getPagination } from '../utils/http';
import { OnboardingTaskCreate, OnboardingTaskUpdate } from '../validation/schemas';

const router = Router();
router.get('/', asyncHandler(async (req, res) => { const { page, limit, offset } = getPagination(req); const pool = await getPool(); const r = await pool.request().input('offset', sql.Int, offset).input('limit', sql.Int, limit).query(`SELECT task_id, client_id, title, status, due_date, COUNT(*) OVER() AS total FROM app.client_onboarding_tasks ORDER BY task_id OFFSET @offset ROWS FETCH NEXT @limit ROWS ONLY`); const total = r.recordset[0]?.total ?? 0; const items = r.recordset.map((row:any)=>{ const { total: _t, ...rest } = row; return rest; }); listOk(res, items, { page, limit, total }); }));
router.get('/:id', asyncHandler(async (req, res) => { const id = Number(req.params.id); if (!Number.isInteger(id) || id <= 0) return badRequest(res,'id must be a positive integer'); const pool = await getPool(); const r = await pool.request().input('id', sql.Int, id).query(`SELECT task_id, client_id, title, status, due_date FROM app.client_onboarding_tasks WHERE task_id=@id`); const row = r.recordset[0]; if (!row) return notFound(res); ok(res, row); }));
router.post('/', asyncHandler(async (req, res) => { const parsed = OnboardingTaskCreate.safeParse(req.body); if (!parsed.success) return badRequest(res, parsed.error.issues.map(i=>i.message).join('; ')); const { client_id, title, status = 'open', due_date = null } = parsed.data as any; const pool = await getPool(); const result = await pool.request().input('client_id', sql.Int, client_id).input('title', sql.NVarChar(200), title).input('status', sql.NVarChar(40), status).input('due_date', sql.DateTime2, due_date).query(`INSERT INTO app.client_onboarding_tasks (client_id, title, status, due_date) OUTPUT INSERTED.task_id, INSERTED.client_id, INSERTED.title, INSERTED.status, INSERTED.due_date VALUES (@client_id, @title, @status, @due_date)`); ok(res, result.recordset[0], 201); }));
router.put('/:id', asyncHandler(async (req, res) => { const id = Number(req.params.id); if (!Number.isInteger(id) || id <= 0) return badRequest(res,'id must be a positive integer'); const parsed = OnboardingTaskUpdate.safeParse(req.body); if (!parsed.success) return badRequest(res, parsed.error.issues.map(i=>i.message).join('; ')); const data = parsed.data; const sets: string[] = []; const pool = await getPool(); const request = pool.request().input('id', sql.Int, id); if (data.title !== undefined) { sets.push('title=@title'); request.input('title', sql.NVarChar(200), data.title); } if (data.status !== undefined) { sets.push('status=@status'); request.input('status', sql.NVarChar(40), data.status); } if (data.due_date !== undefined) { sets.push('due_date=@due_date'); request.input('due_date', sql.DateTime2, data.due_date); } if (!sets.length) return badRequest(res,'No fields to update'); const result = await request.query(`UPDATE app.client_onboarding_tasks SET ${sets.join(', ')} WHERE task_id=@id`); if (result.rowsAffected[0]===0) return notFound(res); const read = await pool.request().input('id', sql.Int, id).query(`SELECT task_id, client_id, title, status, due_date FROM app.client_onboarding_tasks WHERE task_id=@id`); ok(res, read.recordset[0]); }));
router.delete('/:id', asyncHandler(async (req, res) => { const id = Number(req.params.id); if (!Number.isInteger(id) || id <= 0) return badRequest(res,'id must be a positive integer'); const pool = await getPool(); const r = await pool.request().input('id', sql.Int, id).query(`DELETE FROM app.client_onboarding_tasks WHERE task_id=@id`); if (r.rowsAffected[0]===0) return notFound(res); ok(res, { deleted: r.rowsAffected[0] }); }));
export default router;
